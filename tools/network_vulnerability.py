import random
import numpy as np
from .utils import get_igraph, get_full_igraph
import networkx as nx

def remove_nodes_by_attr(G, attr, remove_proportion, ascending=False):
    """
    Remove some proportion of nodes (and attached edges) from a graph based on
    an atrribute's numeric order.

    Parameters
    ----------
    G : NetworkX Graph structure
        Graph of the network.
    attr : string
        Reference attribute (must be on nodes of the graph).
    remove_proportion : float between 0 and 1
        proportion of nodes to be removed
    ascending : boolean
        If True, remove nodes from lower-to-higher attribute value, else
        do it from higher-to-lower attribute value.
    
    Returns
    -------
    NetworkX Graph structure
    """
    
    assert 0<=remove_proportion<=1, 'remove_proportion must be between 0 and 1'
    G_new = G.copy()
    lst = [(G.nodes[n][attr], n) for n in G.nodes]
    if ascending:
        lst= sorted(lst)
    else:
        lst= sorted(lst, reverse=True)
    delete_nodes = [n for m,n in lst[:int(remove_proportion*len(lst))]]
    G_new.remove_nodes_from(delete_nodes)
    return G_new

def remove_nodes_random(G, remove_proportion, random_seed=None):
    """
    Remove some proportion of nodes (and attached edges) randomly.

    Parameters
    ----------
    G : NetworkX Graph structure
        Graph of the network.
    remove_proportion : float between 0 and 1
        proportion of nodes to be removed
    random_seed : int or None
        Random seed for removal. If None, the results will be different
        each time the functions is used
    
    Returns
    -------
    NetworkX Graph structure
    """

    random.seed(random_seed)
    G_new = G.copy()
    delete_nodes = random.sample(list(G.nodes), int(remove_proportion*len(G.nodes)))
    G_new.remove_nodes_from(delete_nodes)
    return G_new

def remove_edges_random(G, remove_proportion, random_seed=None,
                       direction_sensitive=False):
    """
    Remove some proportion of edges randomly.

    Parameters
    ----------
    G : NetworkX Graph structure
        Graph of the network.
    remove_proportion : float between 0 and 1
        proportion of edges to be removed
    random_seed : int or None
        Random seed for removal. If None, the results will be different
        each time the functions is used
    
    Returns
    -------
    NetworkX Graph structure
    """

    random.seed(random_seed)
    G_new = G.copy()
    if direction_sensitive:
        delete_edges = random.sample(list(G.edges), int(remove_proportion*len(G.edges)))
    else:
        delete_edges = []
        for entry in random.sample(_concat_streets(G), int(remove_proportion*len(G.edges))):
            delete_edges += list(entry) 
    G_new.remove_edges_from(delete_edges)
    return G_new

def remove_edges_by_attr(G, attr, remove_proportion, ascending=False, 
                         direction_sensitive=False):
    """
    Remove some proportion of edges from a graph based on an atrribute's 
    numeric order.

    Parameters
    ----------
    G : NetworkX Graph structure
        Graph of the network.
    attr : string
        Reference attribute (must be on nodes of the graph).
    remove_proportion : float between 0 and 1
        proportion of edges to be removed
    ascending : boolean
        If True, remove egdes from lower-to-higher attribute value, else
        do it from higher-to-lower attribute value.
    
    Returns
    -------
    NetworkX Graph structure
    """
    
    assert 0<=remove_proportion<=1, 'remove_proportion must be between 0 and 1'
    G_new = G.copy()
    if direction_sensitive:
        lst = [(G.edges[e][attr], (e,)) for e in G.edges]
    else:
        lst = _concat_streets(G, attr)
    if ascending:
        lst= sorted(lst)
    else:
        lst= sorted(lst, reverse=True)
    delete_edges = []
    for _,entry in lst[:int(remove_proportion*len(lst))]:
        delete_edges += list(entry)
    G_new.remove_edges_from(delete_edges)
    return G_new
    
def _concat_streets(G,attr=None):
    es = {}
    G_new = nx.DiGraph(G).copy()
    for e1,e2 in G_new.edges():
        if (e2,e1) in G_new.edges:
            if ((e2,e1),(e1,e2)) in es.keys(): continue
            if attr != None:
                es[((e1,e2),(e2,e1))] = G_new.edges[(e1,e2)][attr]+G_new.edges[(e2,e1)][attr]
            else:
                es[((e1,e2),(e2,e1))] = 1
        else:
            if attr != None:
                es[((e1,e2),)] = G_new.edges[(e1,e2)][attr]
            else:
                es[((e1,e2),)] = 1
    if attr == None:
        return [m for m in es.keys()]
    else:
        return [(n,m) for m,n in es.items()]

def get_efficiency(G, weight = None, track_progress=False):
    """
    Calculate "efficiency of alternative" metric for vulnerability analysis.
    source: Morelli, A. B., & Cunha, A. L. (2021). Measuring urban road network 
    vulnerability to extreme events: an application for urban floods. Transportation 
    research part D: transport and environment, 93, 102770. 
    https://doi.org/10.1016/j.trd.2021.102770
    ***
    This function tests for all nodes in the system. A function targeted to traffic zones
    and travel behavior, as done in the paper, data is under construction.
    ***
    
    Parameters
    ----------
    G : NetworkX Graph structure
        Graph of the network.
    weight : string
        Attribute to weight shortest distance algorithm. If None, each edge have
        weight 1
    track_progress : boolean
        For tracking progress on Jupyter-Notebooks ONLY
    
    Returns
    -------
    dictionary in form {node:efficiency}
    """
    
    Gig = get_full_igraph(G)
    efficiency = {}
    for node in Gig.vs:
        shrt = Gig.shortest_paths_dijkstra(node,weights=weight)
        total_proximity=0
        for l in shrt[0]:
            if l == 0:
                continue
            total_proximity += 1/l
        total_proximity = total_proximity/len(Gig.vs)
        efficiency[int(node['osmid'])] = total_proximity
    return efficiency

def get_number_of_valid_paths(G,weight=None):
    """
    Calculate number of valid paths for the "continuity" metric for vulnerability analysis.
    cite: Morelli, A. B., & Cunha, A. L. (2021). Verificação de vulnerabilidades em 
    redes de transporte: uma abordagem pela teoria dos grafos. TRANSPORTES, 29(1), 161–172.
    https://doi.org/10.14295/transportes.v29i1.2250

    Parameters
    ----------
    G : NetworkX Graph structure
        Graph of the network.
    weight : string
        Attribute to weight shortest distance algorithm. If None, each edge have weight=1
    
    Returns
    -------
    dictionary in form {node:valid_paths}
    """
    Gig = get_full_igraph(G)
    valid_paths = {}
    for node in Gig.vs:
        shrt = Gig.shortest_paths(node,weights=weight)
        valid = 0
        for l in shrt[0]:
            if l == 0: # if destination equals origin
                continue
            if l!=np.inf:
                valid+=1
        valid_paths[int(node['osmid'])] = valid
    return valid_paths

def get_continuity(G1,G2,nan_values=np.nan,on_graph=False):
    """
    Calculate "continuity" metric for vulnerability analysis.
    cite: Morelli, A. B., & Cunha, A. L. (2021). Verificação de vulnerabilidades em 
    redes de transporte: uma abordagem pela teoria dos grafos. TRANSPORTES, 29(1), 161–172.
    https://doi.org/10.14295/transportes.v29i1.2250

    Parameters
    ----------
    G : NetworkX Graph structure
        Graph of the network.
    weight : string
        Attribute to weight shortest distance algorithm. If None, each edge have
        weight 1
    track_progress : boolean
        For tracking progress on Jupyter-Notebooks ONLY
    
    Returns
    -------
    dictionary in form {node:continuity}
    """
    assert {sorted(list(G1.nodes)) == sorted(list(G2.nodes)),
            'G1 and G2 must have the same set of nodes'}
    #get valid paths for both
    cont_initial = get_number_of_valid_paths(G1)
    cont_final = get_number_of_valid_paths(G2)
    
    #populate dictionary
    cont = {}
    for n in cont_initial:
        if cont_initial[n]!=0:
            cont[n] = cont_final[n]/cont_initial[n]
        else:
            cont[n] = nan_values
    if on_graph:
        G1 = G1.copy()
        nx.set_node_attributes(G1,cont,'continuity')
        return G1
    else:
        return cont