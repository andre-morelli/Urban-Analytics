import random
import numpy as np
from .utils import get_igraph, get_full_igraph

def remove_nodes_by_attr(G, attr, remove_proportion, ascending=False):
    """
    Remove some proportion of nodes (and attached edges) from a graph based on
    an atrribute's numeric order.

    Parameters
    ----------
    G : NetworkX Graph structure
        Graph of the network.
    attr : string
        Reference attribute (must be on nodes of the graph).
    remove_proportion : float between 0 and 1
        proportion of nodes to be removed
    ascending : boolean
        If True, remove nodes from lower-to-higher attribute value, else
        do it from higher-to-lower attribute value.
    
    Returns
    -------
    NetworkX Graph structure
    """
    
    assert 0<=remove_proportion<=1, 'remove_proportion must be between 0 and 1'
    G_new = G.copy()
    lst = [(G.nodes[n][attr], n) for n in G.nodes]
    if ascending:
        lst= sorted(lst)
    else:
        lst= sorted(lst, reverse=True)
    delete_nodes = [n for m,n in lst[:int(remove_proportion*len(lst))]]
    G_new.remove_nodes_from(delete_nodes)
    return G_new

def remove_nodes_random(G, remove_proportion, random_seed=None):
    """
    Remove some proportion of nodes (and attached edges) randomly.

    Parameters
    ----------
    G : NetworkX Graph structure
        Graph of the network.
    remove_proportion : float between 0 and 1
        proportion of nodes to be removed
    random_seed : int or None
        Random seed for removal. If None, the results will be different
        each time the functions is used
    
    Returns
    -------
    NetworkX Graph structure
    """

    
    random.seed(random_seed)
    G_new = G.copy()
    delete_nodes = random.sample(list(G.nodes), int(remove_proportion*len(G.nodes)))
    G_new.remove_nodes_from(delete_nodes)
    return G_new

def remove_edges_by_attr(G, attr, remove_proportion, ascending=False):
    """
    Remove some proportion of edges from a graph based on an atrribute's 
    numeric order.

    Parameters
    ----------
    G : NetworkX Graph structure
        Graph of the network.
    attr : string
        Reference attribute (must be on nodes of the graph).
    remove_proportion : float between 0 and 1
        proportion of edges to be removed
    ascending : boolean
        If True, remove egdes from lower-to-higher attribute value, else
        do it from higher-to-lower attribute value.
    
    Returns
    -------
    NetworkX Graph structure
    """

    G_new = G.copy()
    lst = [(G.edges[e][attr], e) for e in G.edges]
    if ascending:
        lst= sorted(lst)
    else:
        lst= sorted(lst, reverse=True)
    delete_edges = [n for m,n in lst[:int(remove_proportion*len(lst))]]
    G_new.remove_edges_from(delete_edges)
    return G_new

def remove_edges_random(G, remove_proportion, random_seed=None):
    """
    Remove some proportion of edges randomly.

    Parameters
    ----------
    G : NetworkX Graph structure
        Graph of the network.
    remove_proportion : float between 0 and 1
        proportion of edges to be removed
    random_seed : int or None
        Random seed for removal. If None, the results will be different
        each time the functions is used
    
    Returns
    -------
    NetworkX Graph structure
    """

    random.seed(random_seed)
    G_new = G.copy()
    delete_edges = random.sample(list(G.edges), int(remove_proportion*len(G.edges)))
    G_new.remove_edges_from(delete_edges)
    return G_new

def get_efficiency(G, weight = None, track_progress=False):
    """
    Calculate "efficiency of alternative" metric for vulnerability analysis.
    source: Morelli, A. B., & Cunha, A. L. (2021). Measuring urban road network 
    vulnerability to extreme events: an application for urban floods. Transportation 
    research part D: transport and environment, 93, 102770. 
    https://doi.org/10.1016/j.trd.2021.102770
    ***
    This function tests for all nodes in the system. A function targeted to traffic zones
    and travel behavior, as done in the paper, data is under construction.
    ***
    
    Parameters
    ----------
    G : NetworkX Graph structure
        Graph of the network.
    weight : string
        Attribute to weight shortest distance algorithm. If None, each edge have
        weight 1
    track_progress : boolean
        For tracking progress on Jupyter-Notebooks ONLY
    
    Returns
    -------
    dictionary in form {node:efficiency}
    """
    
    Gig = get_full_igraph(G)
    efficiency = {}
    for node in Gig.vs:
        shrt = Gig.shortest_paths_dijkstra(node,weights=weight)
        total_proximity=0
        for l in shrt[0]:
            if l == 0:
                continue
            total_proximity += 1/l
        total_proximity = total_proximity/len(Gig.vs)
        efficiency[int(node['osmid'])] = total_proximity
    return efficiency

def get_continuity(G,track_progress=True):
    """
    Calculate "continuity" metric for vulnerability analysis.
    cite: Morelli, A. B., & Cunha, A. L. (2021). Verificação de vulnerabilidades em 
    redes de transporte: uma abordagem pela teoria dos grafos. TRANSPORTES, 29(1), 161–172.
    https://doi.org/10.14295/transportes.v29i1.2250

    Parameters
    ----------
    G : NetworkX Graph structure
        Graph of the network.
    weight : string
        Attribute to weight shortest distance algorithm. If None, each edge have
        weight 1
    track_progress : boolean
        For tracking progress on Jupyter-Notebooks ONLY
    
    Returns
    -------
    dictionary in form {node:continuity}
    """
    Gig = get_full_igraph(G)
    valid_paths = {}
    for node in Gig.vs:
        shrt = Gig.shortest_paths(node)
        valid = 0
        for l in shrt[0]:
            if l == 0:
                continue
            if l!=np.inf:
                valid+=1
        valid_paths[int(node['osmid'])] = valid
    return valid_paths
